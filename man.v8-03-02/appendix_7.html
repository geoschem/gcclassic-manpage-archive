<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>GEOS&#8211;Chem Online User's Guide</title>


<meta name="description" contents="Information about the GEOS&#8211;Chem tropospheric chemistry model">
<meta name="keywords" contents="Atmospheric Chemistry,Computer Models,GEOS&#8211;Chem,Harvard/GEOS-CTM,GEOS-CTM,GEOS,DAO,Tropospheric Chemistry">
<link rel="stylesheet" href="../../../gc.css" type="text/css"></head><body style="background-color: rgb(255, 255, 255);">
<script type="text/javascript" src="../../../geos_backlinks.js"></script>
<!-- JavaScript for breadcrumb links -->
<p class="size20bi" align="center">GEOS&#8211;Chem
v8&#8211;03&#8211;01 Online User's Guide</p>
<p class="size14bi" align="center"><a href="../../man.v8-03-01/appendix_6.html">Previous</a> | <a href="../../man.v8-03-01/appendix_8.html">Next</a> | <a href="../../man.v8-03-01/appendix_7.html" target="_parent">Printable
View (no frames)</a></p>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size24bi"><a name="A6"></a>Appendix
7: GEOS&#8211;Chem Style Guide </p>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size20bi"><a name="A7.1"></a>A7.1
Background</p>
<p align="justify"><span class="size16bi">(1)</span>
The development
language of GEOS&#8211;Chem is Fortran 90 (F90). This is a recent update of
the Fortran programming language. Fortran 90 introduces several new
features over its predecessor, Fortran 77 (F77), including allocatable
arrays, modules, and new statements. For more information about Fortran
90 you can see the following tutorials:</p>
<ul class="disc">
<li><a href="http://www.nsc.liu.se/%7Eboein/f77to90/f77to90.html">Fortran
90 for the Fortran 77 Programmer</a></li>
<li><a href="http://www.nas.nasa.gov/Groups/SciCon/Tutorials/FORTRAN90/">Fortran
90 Tutorial at NASA/Ames</a></li>
</ul>
<p align="justify">F90 is totally backwards-compatible
with F77. Older
code (a.k.a. "legacy code") which adheres to the F77 standard should
compile and run under F90 with no problems. Although much of the newer
code in GEOS&#8211;Chem is written using the new language features of F90,
many 3rd-party routines included in GEOS&#8211;Chem (such as SMVGEAR and
FAST-J) were written to the Fortran 77 standard. Using F90 ensures that
both the older and newer routines of GEOS&#8211;Chem can be smoothly combined
together.</p>
<p align="justify">In recent years there have also been
further updates
to Fortran, namely Fortran 95 (F95), and Fortran 2000 (F2K). These new
Fortran versions include the new language features which are present in
F90, but generally do not include the old, obsolete features found in
F77. Therefore, pure F77 code may not always compile in F95 and F2K. At
present, GEOS&#8211;Chem has not yet been tested using F95 or F2K compilers.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(2)</span>
GEOS&#8211;Chem code is
written using the fixed-format source code layout of Fortran 90. This
is essentially the same layout from Fortran 77, namely:</p>
<ul class="disc">
<li>
<p align="justify">A comment character (usually <span class="courier16">C</span>) is placed in column 1
(NOTE: the new<span class="courier16"> ! </span>comment
character of F90 can be placed in any column &#8212; this should be used to
create more readable code)</p>
</li>
<li>
<p align="justify">A line continuation character
(usually <span class="courier16">&amp;</span>)
is placed in column 6</p>
</li>
<li>
<p align="justify">Numeric labels can occupy column 2
through column 5</p>
</li>
<li>
<p align="justify">Executable statements begin in
column 7 and extend to column 72</p>
</li>
</ul>
<p align="justify">Using fixed-format source-code layout
will ensure
maximum compatibility between new GEOS&#8211;Chem code and older code which
was originally written to the F77 standard.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(3)</span>
We usually denote
people by their 3-letter email abbreviations (e.g. bmy= Bob Yantosca,
mje = Mat Evans, etc). This is needed when we initial and date various
model revisions, e.g, <span class="courier16">(bmy,
5/1/03)</span></p>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size20bi"><a name="A7.2"></a>A7.2
Headers, declarations, indentations, and white space</p>
<p align="justify"><span class="size16bi">(4)</span>
In GEOS-Chem, we are using ProTeX&nbsp;to produce LaTeX compatible documentation
from Fortran source code. ProTeX is a
perl script developed by GMAO.</p><p align="justify">To use ProTeX, subroutines, functions and modules should have a standard header such
as:</p>
<pre class="courier14">!------------------------------------------------------------------------------<br>! Harvard University Atmospheric Chemistry Modeling Group !<br>!------------------------------------------------------------------------------<br>!BOP<br>!<br>! !ROUTINE: METERO<br>!<br>! !DESCRIPTION: Subroutine METERO calculates meteorological constants needed for the <br>! dry deposition velocity module. (lwh, gmg, djj, 1989, 1994; bmy, 11/21/02)<br>!<br>! Arguments as Output:<br>! ============================================================================<br>! (1 ) CZ1 (REAL*8) : Midpoint height of first model level [m]<br>! (2 ) TC0 (REAL*8) : Array for grid box surface temperature [K]<br>! (3 ) OBK (REAL*8) : Array for the Monin-Obhukov length [m]<br>!<br>!\subsection*{Reference}<br>! (1 ) Wesely, M. L., 1989. <br>! (2 ) Jacob, D.J., and S.C. Wofsy, 1990<br>!<br>!\\<br>!\\<br>! !INTERFACE: <br>!<br> SUBROUTINE METERO( CZ1, TC0, OBK )<br>!<br>! !USES:<br>! <br> USE DAO_MOD, ONLY : AIRDEN, HFLUX, T, TS, USTAR<br> USE PRESSURE_MOD, ONLY : GET_PEDGE <br> IMPLICIT NONE<br># include "CMN_SIZE" ! Size parameters<br># include "CMN_GCTM" ! Physical constants<br>!<br>! !REVISION HISTORY: <br>! (1 ) Now reference GET_PEDGE from "pressure_mod.f". Now reference T from <br>! "dao_mod.f". Removed obsolete code &amp; comments, and added new <br>! documentation header. Now force double precision with "D" <br>! exponents. Now compute OBK here as well. Bundled into F90 module<br>! "drydep_mod.f" (bmy, 11/20/02)<br>!<br>! ! INPUT PARAMETERS:<br>!<br>! ! OUTPUT PARAMETERS:<br>!<br>      REAL*8, INTENT(OUT) :: CZ1(MAXIJ)<br>      REAL*8, INTENT(OUT) :: TC0(MAXIJ)<br>      REAL*8, INTENT(OUT) :: OBK(MAXIJ)<br>!<br>!EOP<br>!------------------------------------------------------------------------------<br>!BOC<br>!<br></pre>
<p align="justify">Note that the header contains the
following:</p>
<ul class="disc">
<li>a description of the routine, the original date and most
recent</li>
<li>modified date, with the initials of who modified it last!)</li>
<li>list of input &amp; output arguments</li>
<li> a list of references (if applicable)</li>
<li>References to F90 modules (if any) after the !USE keyword
followed by the&nbsp;<span class="courier16">IMPLICIT
NONE </span>declaration</li>
<li>Any <span class="courier16">#include</span> declarations for header files.&nbsp;Since we are using the C-preprocessor,
the<span class="courier16"> # </span>must go in
column 1.</li>
<li>Modification NOTES. Each time the file is modified the
REVISION HISTORY section should be updated.</li>
</ul>
<span class="size16bi"></span>
<p align="justify"><span class="size16bi">(4a)</span>
This is then followed by&nbsp;local variables, and external
function declarations:</p>
<pre> !<br>&nbsp;! ! LOCAL VARIABLES:<br> !<br> INTEGER :: I, J, IJLOOP<br> REAL*8 :: P1, P2, THIK, NUM, DEN<br> REAL*8, PARAMETER :: KAPPA = 0.4d0 <br> REAL*8, PARAMETER :: CP = 1000.0d0<br><br> !<br> ! ! EXTERNAL FUNCTIONS:<br> !<br> REAL*8, EXTERNAL :: XLTMMP</pre>
<p align="justify">In F90 you can declare an argument to a
subroutine as<span class="courier16"> INTENT(IN) </span>(read-only),<span class="courier16"> INTENT(OUT) </span>(write-only) or<span class="courier16"> INTENT(INOUT) </span>(read-and-write).
This helps you to prevent overwriting arguments which should not be
overwritten.</p><p align="justify"><span class="size16bi">(4b)</span> &nbsp;We put a header to denote where the beginning of the actual executable statements occurs:</p>
<pre class="courier14">      !=================================================================<br>      ! DO_DRYDEP begins here!<br>      !=================================================================</pre>	  <p align="justify">Note that this 
        header begins with a comment statement in column 7. The top and bottom 
        lines of the header extend to column 72. This provides a convenient 
        reminder for the last allowable column of executable code in fixed-format 
        Fortran.</p>
<p align="justify"><span class="size16bi">(4c)</span> And finally, at the end of the routine we put:</p><pre class="courier14">!EOC <br></pre><p>The
format of this header is a standard ProTeX prologue. ProTeX is a perl
script developed by GMAO to produce LaTeX compatible documentation from
Fortran source code.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(5)</span>
GEOS&#8211;Chem source code should be written in ALL CAPS. This will help to
prevent confusion between characters (e.g. the lowercase<span class="courier16"> l </span>and the number<span class="courier16"> 1,</span>
which in some fonts can look a lot alike). Editors such as emacs and
Xemacs can "colorize" the different words in a program (e.g.
statements, variables, and quoted text are rendered in different
colors) and thus makes the code more readable.</p>
<p align="justify">NOTE: Since GEOS&#8211;Chem contains much
3rd-party code,
there may be instances where source code is in lowercase. This is OK,
since this code comes to us from outside sources, and it is often
cumbersome to convert already-existing code to uppercase.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(6)</span>
Each level of indentation should be 3 columns deeper than the last. For
example:</p>
<pre> 1  2  3  4<br>1234567890123456789012345678901234567890<br> IF ( X == 0 ) THEN<br>    PRINT*, 'Hello, X = 0!'<br> ENDIF</pre>
<p align="justify">A good editor such as Emacs or Xemacs
will indent for you automatically.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(7)</span>
You should omit
indentation for each line of a multiple DO loop. This helps to prevent
loop statements from having to be continued on the next line. For
example, instead of writing:</p>
<pre> DO N = 1, NNPAR<br>    DO L = 1, LLPAR<br>       DO J = 1, JJPAR<br>          DO I = 1, IIPAR<br>             A(I,J,L,N) = A(I,J,L,N) / 2.0d0<br>          ENDDO<br>       ENDDO<br>    ENDDO<br> ENDDO</pre>
<p align="justify">it is more readable to write:</p>
<pre> DO N = 1, NNPAR<br> DO L = 1, LLPAR<br> DO J = 1, JJPAR<br> DO I = 1, IIPAR<br>    A(I,J,L,N) = A(I,J,L,N) / 2.0d0<br> ENDDO<br> ENDDO<br> ENDDO<br> ENDDO</pre>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(8)</span>
Use LOTS of white space to separate code. For example instead of</p>
<pre> IF(X.eq.0)CALL DOLOOP(X,Y,Z,A,B,C,1,2,3)</pre>
<p align="justify">type:</p>
<pre> IF ( X == 0 ) CALL DOLOOP( X, Y, Z, A, B, C, 1, 2, 3 )</pre>
<p align="justify">This makes the code much more readable,
which helps
to prevent bugs! Continue the statement to the next line if necessary.
In the above example, we also have used the new F90 equality test
operator<span class="courier16"> == </span>(see
below for more information). </p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(9)</span>
Line up quantities in assignment statements, e.g. instead of:</p>
<pre> A=1<br> THISLOOP=2<br> C=3<br> D=THISLOOP*C - A</pre>
<p align="justify">it is more readable to type: </p>
<pre> A        = 1<br> THISLOOP = 2<br> C        = 3 <br> D        = ( THISLOOP * C ) - A</pre>
<p align="justify">Also, parentheses should be used to
ensure that terms will be grouped correctly.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(10)</span>
Arrays should be written with no white space between the indices:</p>
<pre> A = X(I,J,L)</pre>
<p align="justify">Functions and WRITE statements should
contain some white space between arguments, such as:</p>
<pre> A = MYFUNCTION( I, J, L )<br> WRITE( 6, '(a)' ) A<br></pre>
<p align="justify">Also note that the '(' should follow
directly after
the last character of the function name or WRITE statement (i.e. don't
leave white space).</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(11)</span>
Arguments in
subroutine or function calls should be lined up. If there are an even
number of arguments then these can be broken up symmetrically:</p>
<pre> CALL MYSUB( THIS_A, THIS_B, THIS_C,<br> &amp; THIS_D, THIS_E, THIS_F )<br></pre>
<p align="justify">or</p>
<pre> X = MYFUNCTION( THIS_A, THIS_B, THIS_C,<br> &amp;               THIS_D, THIS_E, THIS_F )</pre>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size20bi"><a name="A7.3"></a>A7.3
Numeric and character data types</p>
<p align="justify"><span class="size16bi">(12)</span>
GEOS&#8211;Chem uses the following data types:</p>
<pre> LOGICAL --&gt; TRUE or FALSE switch<br> INTEGER --&gt; 32 byte integer value<br> REAL*4 --&gt; 32 byte floating-point value<br> REAL*8 --&gt; 64 byte floating-point value<br> CHARACTER(LEN=255) --&gt; string w/ 255 characters (the max limit)</pre>
<p>where</p>
<pre> INTEGER can express numbers from -2 x 10<sup>9</sup> to +2 x 10<sup>9</sup><br>REAL*4 can express numbers from -10<sup>38</sup> to +10<sup>38</sup><br>REAL*8 can express numbers from -10<sup>312</sup> to +10<sup>312</sup></pre>
<p align="justify">The default floating-point type for
GEOS&#8211;Chem should
be REAL*8, as this will help to prevent roundoff and precision
truncation errors. However, there are some instances when the REAL*4
data type should be used instead of REAL*8, such as: </p>
<ul class="disc">
<li>
<p align="justify">Diagnostic arrays. GEOS&#8211;Chem
diagnostic values rarely exceed 10<sup>38</sup>, since they
are usually in units such as kg, v/v, ppbv, or molecules/cm<sup>2</sup>/s.</p>
</li>
<li>
<p align="justify">Arrays and scalars required for
binary file I/O. Declaring these types of variables<span class="courier16"> REAL*4 </span>will help to keep
file sizes as small as possible, thus saving disk space.</p>
</li>
</ul>
<p align="justify">Some third-party routines used in
GEOS&#8211;Chem (such as TPCORE) use the<span class="courier16">
REAL </span>datatype. On Cray machines the type<span class="courier16"> REAL </span>is assumed to be<span class="courier16"> REAL*8.</span> However, on most
other platforms, including SGI, Alpha, and Suns, the<span class="courier16"> REAL </span>datatype is assumed to
be<span class="courier16"> REAL*4.</span>
You must use a special compiler switch (-r8 for SGI and Alpha, or
-xtypemap=real:64 for Sun/Sparc) when compiling in order to force
variables of type<span class="courier16"> REAL </span>to
be interpreted as<span class="courier16"> REAL*8.</span>
This is already handled for you in the Makefile. </p>
<p class="size16bi" align="justify">NOTE: See the <a href="http://wiki.seas.harvard.edu/geos-chem/index.php/Floating_point_math_issues" target="_blank">GEOS&#8211;Chem wiki page on floating point math
issues</a> for more information. </p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(13)
</span>If you are assigning a constant value to a<span class="courier16"> REAL*8 </span>number, use the<span class="courier16"> D </span>exponent rather than the<span class="courier16"> E </span>exponent. For example,
instead of:</p>
<pre> REAL*8 :: PI<br> PI = 3.14159265359e0</pre>
<p align="justify">use</p>
<pre> REAL*8 :: PI<br> PI = 3.14159265358979323d0</pre>
<p align="justify">In F90, the<span class="courier16">
E </span>exponent only yields about 7 decimal places of
precision, whereas the<span class="courier16"> D </span>exponent
yields 15 or 16 decimal places of precision. This is important to help
prevent roundoff errors.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(14)</span>
If you don't know
a priori how long a string will be, declare it with 255 characters. You
can always use the TRIM statement to strip off excess white space at
the end. For example:</p>
<pre> CHARACTER(LEN=255) :: STR<br> <br> STR = 'I am the very model of a modern major general...'<br><br> WRITE( 6, '(a)' ) TRIM( STR )</pre>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size20bi"><a name="A7.4"></a>A7.4
Converting from number to character (and vice versa)</p>
<p align="justify"><span class="size16bi">(15)</span>
In many GEOS&#8211;Chem
routines, we must create a character variable for a file name which
contains the current date. This requires us to be able to convert from
INTEGER to CHARACTER. The preferred way to do this is via a FORTRAN
internal write. This is similar to a regular WRITE statement, only that
the unit number is replaced by a character variable. Think of us
"writing" our number into a character variable.</p>
<pre> ! Declare variables<br> CHARACTER(LEN=8) :: DATE_STR<br> INTEGER :: DATE = 20010701<br> ... <br> ! FORTRAN internal write -- converts number to string<br> WRITE( DATE_STR, '(i8)' ) DATE</pre>
<p align="justify">Caveat: The FORTRAN internal write
listed above is
not supported on the PGI Linux compiler. If you are using this
compiler, you must use the<span class="courier16"> ENCODE </span>function
to convert from number to character, as follows:</p>
<pre class="courier16" align="left"> ! Declare variables<br> CHARACTER(LEN=8) :: DATE_STR<br> INTEGER :: DATE = 20010701<br> ...<br><br> ! Writes value from DATE into DATE_STR<br> ENCODE( 8, '(i8)', DATE_STR ) DATE</pre>
<p align="justify">In the call to<span class="courier16">
ENCODE </span>you must specify the length of the character variable (in this case,
8), the
format string, and the character variable.<span class="courier16"> ENCODE </span>does the
same thing as the internal write statement listed above.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(16)</span>
If you want to
extract numbers from a character string and store them into an integer
variable, then the preferrered method is a FORTRAN internal read. This
is the reverse of the FORTRAN internal write described above:</p>
<pre class="courier16" align="left"> ! Declare variables<br> CHARACTER(LEN=8) :: DATE_STR = '20010101'<br> INTEGER :: DATE<br> ...<br><br> ! FORTRAN internal read -- converts string to number<br> READ( DATE_STR, '(i8)' ) DATE</pre>
<p align="justify">The PGI Linux compiler does not also
support FORTRAN internal reads. You must use the<span class="courier16"> DECODE </span>function (which is
the reverse of the<span class="courier16"> ENCODE </span>function
described above).<span class="courier16"> DECODE </span>is
called as follows: :</p>
<pre class="courier16" align="left"> ! Declare variables<br> CHARACTER(LEN=8) :: DATE_STR = '20010101'<br> INTEGER :: DATE<br> ...<br><br> ! Reads string value from DATE_STR into DATE<br> DECODE( 8, '(i8)', DATE_STR ) DATE</pre>
<p align="justify">As with<span class="courier16">
ENCODE,</span> you must specify in the call to<span class="courier16"> DECODE </span>the length of the character variable
(in this case, 8), the format string, and the character
variable.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(17)</span>
In practice, when
writing GEOS&#8211;Chem code, you will have to use both methods
simultaneously, separated by the appropriate C&#8211;preprocessor compiler
flags.</p>
<pre class="courier16" align="left"> ! Declare variables<br><br> CHARACTER(LEN=8) :: DATE_STR<br> INTEGER :: DATE = 20010701<br> <br># include "define.h" ! C-preprocessor flags<br> <br>#if defined( LINUX )<br> ! Write numeric value from DATE into DATE_STR for PGI Linux<br> ENCODE( 8, '(i8)', DATE_STR ) DATE<br>#else<br> ! FORTRAN Internal Write for other platforms<br> WRITE( DATE_STR, '(i8)' ) DATE<br>#endif</pre>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size20bi"><a name="A7.5"></a>A7.5
New language features of Fortran 90</p>
<p align="justify"><span class="size16bi">(18)</span>
Use the new F90-style operators instead of the F77-style operators:</p>
<pre>	== instead of .EQ.<br>	/= instead of .NE.<br>	&gt; instead of .GT.<br>	&gt;= instead of .GE.<br>	&lt; instead of .LT.<br>	&lt;= instead of .LE.<br></pre>
<p align="justify">These are easier to read and take up
only one or two spaces instead of four. The operators<span class="courier16"> .AND. .OR. .NOT. </span>are still
the same in F90 as in F77. </p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(19)</span>
The F90 comment character<span class="courier16"> ! </span>should
be used instead of<span class="courier16"> C.</span>
The advantage of<span class="courier16"> ! </span>is
that this character can be used to start comments in any column, whereas<span class="courier16"> C </span>can only start a comment
in column 1.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(20)</span>
Use<span class="courier16"> &amp; </span>as
the continuation character in column 6. This is the "official" F90
continuation character. This will make it easier to merge free-format
and fixed-format code if necessary.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(21)</span>
In F90, you can also zero all elements of an array in one statement,
For example:</p>
<pre> INTEGER :: ARRAY(10,10)<br><br> ARRAY(:,:) = 0</pre>
<p align="justify">You can also leave off the default
array mask<span class="courier16"> (:,:),</span> so</p>
<pre> ARRAY = 0 </pre>
<p align="justify">is also acceptable. However writing
this as<span class="courier16"> ARRAY(:,:) </span>makes
it clear to the user that this is an array and not a scalar variable.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(22)</span>
In F90, a<span class="courier16"> PARAMETER </span>can
now be initialized on the same line where it is declared. For example,
in F77, you would do this:</p>
<pre> REAL*8 PI<br> PARAMETER( PI = 3.14159265358979323 )</pre>
<p align="justify"> but in F90 you can do this: </p>
<pre> REAL*8, PARAMETER :: PI = 3.14159265358979323d0</pre>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"></p>
<p><span class="size16bi">(23)</span> The<span class="courier16"> DATA </span>statement in F77 can
be replaced with F90 direct assignment. For example:</p>
<pre> REAL*8 A(2)<br> DATA A / 1.0, 2.0 /</pre>
<p align="justify">can now be written in F90 as:</p>
<pre> REAL*8 :: A(2) = (/ 1.0d0, 2.0d0 /)</pre>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(24)
</span> In F90, the<span class="courier16"> SAVE </span>attribute
can now be included on the same line where the variable is declared. In
F77 you would have had to write:</p>
<pre> LOGICAL FIRSTTIME <br> SAVE FIRSTTIME<br> DATA FIRSTTIME / .TRUE. /</pre>
<p align="justify">but now in F90 you can write:</p>
<pre> LOGICAL, SAVE :: FIRSTTIME = .TRUE.</pre>
<p align="justify"></p>
Note:<span class="courier16"> SAVE</span>d
variables keep their values from one call to the next. This allows you
to do some initialization only on the first call to a subroutine, for
example:
<p></p>
<pre> LOGICAL, SAVE :: FIRSTTIME = .TRUE. <br><br> IF ( FIRSTTIME ) THEN<br> PRINT*, 'This is the first time this routine is called!'<br> FIRSTTIME = .FALSE.<br> ENDIF</pre>
<p align="justify">Since the value of<span class="courier16"> FIRSTTIME </span>is saved between
calls, the sentence above will only be printed out on the first call to
the subroutine.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(25)</span>
In F90, the<span class="courier16"> EXTERNAL </span>attribute
can now be included on the same line where a function's' type is
declared. In F77 you would have had to write:</p>
<pre> INTEGER MYFUNC<br> EXTERNAL MYFUNC</pre>
<p align="justify">but in F90 you can now write</p>
<pre> INTEGER, EXTERNAL :: MYFUNC</pre>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(26)</span>
You can use the new F90<span class="courier16"> SELECT
CASE </span>statement to pick from a list of options. In F77 you
would have had to write:</p>
<pre> IF ( X .EQ. 1 ) THEN<br> CALL MYSUB( X1 )<br> ELSE IF ( X .EQ. 2 ) THEN <br> CALL MYSUB( X2 )<br> ELSE<br> CALL MYSUB( X0 )<br> ENDIF</pre>
<p align="justify">but in F90 this may be written as:</p>
<pre> SELECT CASE ( X )<br> CASE( 1 )<br> CALL MYSUB( X1 )<br> CASE( 2 ) <br> CALL MYSUB( X2 )<br> CASE DEFAULT<br> CALL MYSUB( X0 )<br> END SELECT</pre>
<p align="justify"><span class="courier16">SELECT
CASE </span>also works with character constants:</p>
<pre> SELECT CASE ( TRIM( TRACERNAME ) )<br> CASE( 'NOx' )<br> CALL MYSUB( 1 )<br> CASE( 'Ox' ) <br> CALL MYSUB( 2 )<br> CASE DEFAULT<br> CALL MYSUB( 3 )<br> END SELECT</pre>
<p align="justify">A note of warning: You cannot do<span class="courier16"> CASE( X ) </span>where<span class="courier16"> X </span>is&nbsp;variable, or
else the compiler will balk. In that case you must resort to the<span class="courier16"> IF - ELSE IF </span>block
structure as shown above. </p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(27)</span>
Use the F90 intrinsic functions<span class="courier16">
LOG( X ) </span>and<span class="courier16"> LOG10(
X ) </span>to take the natural and common logarithms of X. Here
X may be declared either as<span class="courier16"> REAL*4
</span>or <span class="courier16">REAL*8. </span></p>
<p align="justify">The F77 intrinsic functions<span class="courier16"> ALOG( X ) </span>and<span class="courier16"> ALOG10( X ) </span>are not
supported on some compilers, such as on the Alpha platform. This can
lead to a compile time error.</p>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size20bi"><a name="A7.6"></a>A7.6
Math optimizations</p>
<p align="justify"><span class="size16bi">(28)</span>Logarithms
and
exponentiation are the most computationally expensive mathematical
functions. Therefore, if you wish to code a polynomial expression, do
not use the traditional formulation, i.e.:</p>
<pre class="courier14"> Y = A0 + A1*X + A2*X**2 + A3*X**3 + A4*X**4 + A5*X**5 </pre>
<p align="justify">but write the expression as:</p>
<pre class="courier14"> Y = A0 + X* ( A1 + X* ( A2 + X* ( A3 + X* ( A4 + X* ( A5 )))))</pre>
<p align="justify">This modified polynomial expression has
the benefit
of eliminating the costly exponentiations. A Nth order polynomial will
now only require N multiplications. This will execute much faster than
the traditional formulation.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(29)</span>
Although it is tempting to replace<span class="courier16">
EXP( &#8211;x ) </span>with the first-order approximation <span class="courier16">1 &#8211; x,</span> this can result in
negative values for certain values of<span class="courier16">
x.</span> This can cause negative tracer concentrations.</p>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size20bi"><a name="A7.7"></a>A7.7
DO loops</p>
<p align="justify"><span class="size16bi">(30)</span>
In F77, if you wanted to skip ahead in a DO-loop you would have written:</p>
<pre> DO 100 I = 1, 1000<br> IF ( X(I) .EQ. 0 ) GOTO 100<br> PRINT*, X(I)<br>100 CONTINUE</pre>
<p align="justify"> But now in F90 you can write this
using the<span class="courier16"> CYCLE </span>statement:</p>
<pre> DO I = 1, 1000<br> <br> ! Skip to next iteration<br> IF ( X(I) == 0 ) CYCLE<br> <br> ! Print<br> PRINT*, X(I)<br> ENDDO</pre>
<p align="justify">Also notice that you no longer have to
use a labeled<span class="courier16"> CONTINUE </span>statement
to end a DO-loop in F90. This results in cleaner code.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(31)</span>
If you wanted to exit from a DO-loop, then in F77 you had to do
something like this:</p>
<pre> C Do-loop<br> DO 100 I = 1, 1000<br> IF ( X(I) .EQ. 0 ) GOTO 200<br> PRINT*, 'inside loop'<br>100 CONTINUE<br><br>C Continue outside loop<br>200 CONTINUE<br> PRINT*, 'outside loop'</pre>
<p align="justify">but in F90 you can now write this using
the<span class="courier16"> EXIT </span>statement:</p>
<pre> DO I = 1, 1000<br> <br> ! Exit from this loop totally<br> IF ( X(I) == 0 ) EXIT<br> <br> ! Print info if we have not exited<br> WRITE( 6, '(''Iteration: '', i5, f13.6)' ) I, X(I)<br> ENDDO <br><br> PRINT*, 'outside loop'</pre>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(32)
</span>DO loops should
be structured so that elements of an array are accessed in the same
order in which they are stored in memory. This will result in code that
executes efficiently.</p>
<p align="justify">Fortran (including the F90 and F77
versions) is a
column-major language, which means that arrays are stored by columns
first, then rows. If you have declared an array such as:</p>
<pre> INTEGER :: I, J, L, N<br> REAL*8 :: ARRAY(IIPAR,JJPAR,LLPAR,NNPAR)</pre>
<p align="justify">then for optimal efficiency, the
leftmost dimension
(I) needs to vary the fastest, and needs to be accessed by the
innermost DO-loop. Then the next leftmost dimension (J) should be
accessed by the next innermost DO-loop, and so on. Therefore, the
proper way to loop over this array is:</p>
<pre> DO N = 1, NNPAR<br> DO L = 1, LLPAR<br> DO J = 1, JJPAR<br> DO I = 1, IIPAR<br>    ARRAY(I,J,L,N) = ARRAY(I,J,L,N) * 2.0d0<br> ENDDO<br> ENDDO<br> ENDDO<br> ENDDO </pre>
<p align="justify">Note that the I index is varying most
often, since it is the innermost DO-loop, then J, L, and N. This is
opposite to how a car's speedometer varies (i.e. rightmost index varies
the fastest).</p>
<p align="justify">If you loop through an array in this
fashion, with
leftmost indicies varying fastest, then the code minimizes the number
of times it has to load subsections of the array into cache memory. In
this optimal manner of execution, all of the array elements sitting in
the cache memory are read in the proper order before the next array
subsection needs to be loaded into the cache. However, if you step
through array elements in the wrong order, the number of cache loads is
proportionally increased. Since it takes a finite amount of time to
reload array elements into cache memory, the more times you have to
access the cache, the longer it will take the code to execute. This can
slow down the code dramatically.</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(33)</span>
In F90 you may
also write an "infinite" DO loop (i.e. a loop without limits). This is
often useful for reading data from a file whose length you do not know.
Here is one such example:</p>
<pre> INTEGER :: I, IOS, IUNIT<br> REAL*8 :: A(10000) <br> <br> ! Open file<br> OPEN( IUNIT, FILE='myfile.txt', IOSTAT=IOS )<br><br> ! Quit if we can't open the file<br> IF ( IOS /= 0 ) THEN<br>    PRINT*, 'Error opening the file!'<br>    STOP<br> ENDIF<br><br> ! Infinite DO loop for reading data from "myfile.txt"<br> DO<br><br>    ! Read I and A(I) from the file<br>    READ( IUNIT, '(i3,f11.3)', IOSTAT=IOS ) I, A(I)<br> <br>    ! IOS &lt; 0 is end-of-file, so we exit the loop<br>    IF ( IOS &lt; 0 ) EXIT<br>	<br>    ! If IOS &gt; 0, then this is an I/O error,<br>    ! so we print an error msg and quit<br>    IF ( IOS &gt; 0 ) THEN<br>       PRINT*, 'I/O error reading from file!<br>       STOP<br>    ENDIF<br> ENDDO<br> <br> ! Close the file after we exit the loop<br> CLOSE( IUNIT )</pre>
<p align="justify">In this example, the DO loop wants to
execute forever, but it is stopped by an external criterion&#8212;the end of
the file. The <span class="courier16">OPEN, READ, </span>and<span class="courier16"> CLOSE </span>functions can return
the I/O status to a variable if you specify via the<span class="courier16"> IOSTAT </span>keyword.
If the I/O status variable (in this case, named IOS) is negative, then
this is a normal end-of-file condition, and so we can just exit the
loop and close the file. However, if<span class="courier16">
IOS </span>is
a nonzero, positive number, then this means that we have encountered a
real error condition. It is possible to obtain more information from
the I/O status value by using the explain command (SGI only).</p>
<p align="left"><img src="../../../img/black_rule.jpg" height="2" width="10%"></p>
<p align="justify"><span class="size16bi">(34)</span>
Use the following conventions for DO-loop and array indices which
pertain to physical dimensions:</p>
<pre> Use I for the longitude index<br> Use J for the latitude index<br> Use L for the altitude index<br> Use N for the tracer or species index</pre>
<p align="justify">Therefore, any DO-loop which uses<span class="courier16"> I, J, </span>and<span class="courier16"> L </span>may be assumed to be
looping over grid box longitude, latitude, and altitude dimensions. Any
DO-loop which uses<span class="courier16"> N </span>may
be assumed to be looping over either tracer or species. These special
indices should NOT be used to refer other quantities. In this way if
the code prints out an error message such as</p>
<pre> Error at grid box (I,J) = (23,34)!</pre>
<p align="justify">it will be immediately understood by
all GEOS&#8211;Chem users that these are the longitude and latitude indices
of the box where the error happened.</p>
<p align="justify">NOTE: In some 3rd-party routines,<span class="courier16"> K </span>is used instead of<span class="courier16"> L </span>for the altitude index.
Since it is often difficult to rewrite entire sections of 3rd-party
code, it is allowable to leave<span class="courier16"> K </span>as
the altitude index in these routines. However, any new sections of code
that are written by GEOS&#8211;Chem users should use<span class="courier16">
L </span>instead of<span class="courier16"> K </span>for
the altitude index.</p>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size20bi"><a name="A7.8"></a>A7.8
Fortran-90 modules</p>
<p align="justify"><span class="size16bi">(35)</span>
New code should
be written in Fortran 90 modules. These allow you to save both
variables and routines within a single program unit. A module in F90 is
similar to a class in Java or C++.</p>
<p align="justify">A sample module is provided below.</p>
<pre class="courier14">!------------------------------------------------------------------------------<br>!          Harvard University Atmospheric Chemistry Modeling Group            !<br>!------------------------------------------------------------------------------<br>!BOP<br>!<br>! !MODULE: MY\_MODULE<br>!<br>! !DESCRIPTION: \subsection*{Overview}<br>! Module MY\_MODULE contains variables and routines to do something.<br>! (bmy, 5/1/03)<br>!\\<br>!\\<br>!<br>! !INTERFACE<br>       MODULE MY_MODULE<br>!<br>! !USES:<br>! <br>      IMPLICIT NONE<br><br> ! Make everything private...<br>      PRIVATE<br>&nbsp;!<br> ! !PUBLIC MEMBER FUNCTIONS:&nbsp;<br> !<br>      PUBLIC :: DRIVER<br>      PUBLIC :: INIT_MY_MODULE<br>      PUBLIC :: CLEANUP_MY_MODULE<br> !<br> ! !REVISION HISTORY:<br> !  (1 ) Bug fix in MY_SUBROUTINE (bmy, 5/1/03)<br>&nbsp;!EOP<br> !------------------------------------------------------------------------------<br> !<br> ! !PRIVATE DATA MEMBERS:<br> !<br>      ! Argument to the SIN function<br>      REAL*8, ALLOCATABLE :: B(:)<br><br>      CONTAINS<br><br>!------------------------------------------------------------------------------<br>!          Harvard University Atmospheric Chemistry Modeling Group            !<br>!------------------------------------------------------------------------------<br>!BOP<br>!<br>! !IROUTINE: DRIVER<br>!<br>! !DESCRIPTION: \subsection*{Overview}<br>! Subroutine DRIVER is the driver routine for MY_MODULE. (bmy, 5/1/03)<br>!\\<br>!\\<br>!<br>! !INTERFACE:<br>      SUBROUTINE DRIVER<br>!<br>! !REVISION HISTORY:<br>!<br>!EOP<br>!------------------------------------------------------------------------------<br>!BOC<br>!<br>! !LOCAL VARIABLES:<br>!<br>      LOGICAL, SAVE :: FIRST = .TRUE.<br>      INTEGER, :: I<br>      REAL*8 :: X, Y1, Y2<br>      REAL*8, PARAMETER :: PI180 = 180d0 / 3.14159265358979323d0<br> <br>      !=================================================================<br>      ! DRIVER begins here!<br>      !=================================================================<br> <br>      ! Initialize <br>      IF ( FIRST ) THEN<br>         CALL INIT_MY_MODULE<br>      ENDIF<br> <br>      !=================================================================<br>      ! Loop over degrees<br>      !=================================================================<br>      DO I = 1, 360<br> <br>         ! Convert to radians<br>         B = DBLE( I ) / PI180<br> <br>         ! Call subroutine<br>         CALL MY_SUBROUTINE( B(I), Y1 )<br> <br>         ! Call function<br>         Y2 = MY_FUNCTION( B(I) )<br> <br>         ! Write output<br>         WRITE( 6, '(i3, 1x, 3(f13.6,1x))' ) I, B(I), Y1, Y2<br>      ENDDO <br> <br>      ! Return to calling program<br>      END SUBROUTINE DRIVER<br>!EOC<br>!-----------------------------------------------------------------------------<br>!          Harvard University Atmospheric Chemistry Modeling Group            !<br>!------------------------------------------------------------------------------<br>!BOP<br>!<br>! !IROUTINE: MY\_SUBROUTINE<br>!<br>! !DESCRIPTION: \subsection*{Overview}<br>! Function MY_SUBROUTINE returns the sine of a number. (bmy, 5/1/03)<br>!\\<br>!\\<br>!<br>! !INTERFACE:<br><br>      SUBROUTINE MY_SUBROUTINE( X, Y )<br>!<br>! !INPUT PARAMETERS: <br>!<br>      ! Argument for the sine function<br>      REAL*8, INTENT(IN) :: X<br>!<br>! !RETURN VALUE:<br>!     <br>      REAL*8, INTENT(OUT) :: Y <br>!<br>! !REVISION HISTORY:<br>! (1 ) Corrected typographic error (bmy, 5/1/03)<br>!EOP<br>!------------------------------------------------------------------------------<br>!BOC<br> <br>      !=================================================================<br>      ! MY_SUBROUTINE begins here!<br>      !=================================================================<br>      Y = SIN( X )<br> <br>      ! Return to calling program<br>      END SUBROUTINE MY_SUBROUTINE<br>!EOC<br>!-----------------------------------------------------------------------------<br>!          Harvard University Atmospheric Chemistry Modeling Group            !<br>!------------------------------------------------------------------------------<br>!BOP<br>!<br>! !IROUTINE: MY\_FUNCTION<br>!<br>! !DESCRIPTION: \subsection*{Overview}<br>! Function MY_FUNCTION returns the sine of a number. (bmy, 5/1/03)<br>!\\<br>!\\<br>!<br>! !INTERFACE:<br><br>      FUNCTION MY_FUNCTION( X ) RESULT( Y )<br>!<br>! !INPUT PARAMETERS: <br>!<br>      ! Argument for the sine function<br>      REAL*8, INTENT(IN) :: X<br>!<br>! !RETURN VALUE:<br>!     <br>      REAL*8, INTENT(OUT) :: Y <br>!<br>! !REVISION HISTORY:<br>!<br>!EOP<br>!------------------------------------------------------------------------------<br>!BOC<br> <br>      !=================================================================<br>      ! MY_FUNCTION begins here!<br>      !=================================================================<br>      Y = SIN( X )<br> <br>      ! Return to calling program<br>      END FUNCTION MY_FUNCTION<br>!EOC<br>!------------------------------------------------------------------------------<br>!!          Harvard University Atmospheric Chemistry Modeling Group            !<br>!------------------------------------------------------------------------------<br>!BOP<br>!<br>! !IROUTINE: INIT\_MY\_MODULE<br>!<br>! !DESCRIPTION: \subsection*{Overview}<br>! Subroutine INIT\_MY\_MODULE allocates and zeroes the B array. (bmy, 5/1/03)<br>!\\<br>!\\<br>!<br>! !INTERFACE:<br>      SUBROUTINE INIT_MY_MODULE<br>!<br>! !USES<br>!<br>      USE ERROR_MOD, ONLY : ALLOC_ERR<br>!<br>! !REVISION HISTORY:<br>!<br>!EOP<br>!------------------------------------------------------------------------------<br>!BOC<br>!<br>! !LOCAL VARIABLES<br>      INTEGER :: AS<br> <br>      !=================================================================<br>      ! INIT_MY_MODULE begins here!<br>      !=================================================================<br> <br>      ! Allocate B, check status<br>      ALLOCATE( B(360), STAT=AS )<br> <br>      ! Error check<br>      IF ( AS /= 0 ) CALL ALLOC_ERR( 'B' )<br> <br>      ! Zero B<br>      B(:) = 0d0<br> <br>      ! Return to calling program<br>      END SUBROUTINE INIT_MY_MODULE<br>!EOC<br>!-----------------------------------------------------------------------------<br>!!          Harvard University Atmospheric Chemistry Modeling Group            !<br>!------------------------------------------------------------------------------<br>!BOP<br>!<br>! !IROUTINE: CLEANUP\_MY\_MODULE<br>!<br>! !DESCRIPTION: \subsection*{Overview}<br>! Subroutine CLEANUP_MY_MODULE deallocates all module arrays. (bmy, 5/1/03)<br>!\\<br>!\\<br>!<br>! !INTERFACE:<br>      SUBROUTINE CLEANUP_MY_MODULE <br>!<br>! !REVISION HISTORY:<br>!<br>!EOP<br>!------------------------------------------------------------------------------<br>!BOC<br><br>      !=================================================================<br>      ! CLEANUP_MY_MODULE begins here!<br>      !=================================================================<br>      IF ( ALLOCATED( B ) ) DEALLOCATE( B )<br><br>      ! Return to calling program<br>      END SUBROUTINE CLEANUP_MY_MODULE<br><br>!-----------------------------------------------------------------------------<br><br> END MODULE MY_MODULE<br><br>!EOC</pre>
<p align="justify">F90 modules for GEOS&#8211;Chem should
contain the following features:</p>
<ul class="disc">
<li>
<p align="justify">Module header &#8212; similar to the
subroutine header. Contains a list of all module variables, routines,
and modification notes.</p>
</li>
<li>
<p align="justify"> <span class="courier16">PRIVATE
</span>declarations &#8212; you can "hide" certain routines or
variables within a F90 module from other routines or modules. Ideally
your module will be like a "black box" with only a few routines or
variables that are publicly accessible. By convention, in GEOS-Chem, we
declare everything <span class="courier16">PRIVATE</span>
first then indicate the public routines.</p>
</li>
<li>
<p align="justify"> <span class="courier16">IMPLICIT
NONE </span>&#8212; if you declare<span class="courier16">
IMPLICIT NONE </span>once at the top of the module, then you
don't have to declare it in the individual subroutines; the declaration
"carries through" below.</p>
</li>
<li>
<p align="justify"> Module variables and arrays -- any
variables declared above the<span class="courier16">
CONTAINS </span>statement are as if they were stored in common
blocks -- that is, they are preserved between calls to the various
module routines. Also, you should declare module arrays as<span class="courier16"> ALLOCATABLE </span>whenever
possible. This allows you to only set aside memory for that array if a
certain routine is called. This results in more efficient memory
management.</p>
</li>
<li>
<p align="justify"> <span class="courier16">CONTAINS
</span>statement &#8212; all module variables and<span class="courier16"> PRIVATE </span>declarations go
above the<span class="courier16"> CONTAINS </span>statement.
Module routines and functions go below the<span class="courier16">
CONTAINS </span>statement.</p>
</li>
<li>
<p align="justify"> Subroutines and functions &#8212; your
module will contain various subroutines and functions depending on the
particular needs at hand.</p>
</li>
<li>
<p align="justify">An "INIT" module &#8212; your module
should have a subroutine named<span class="courier16">
INIT_modulename,</span> which initializes and allocates all
module arrays.</p>
</li>
<li>
<p align="justify">A "CLEANUP" module &#8212; your module
should have a subroutine named <span class="courier16">CLEANUP_modulename,</span>
which deallocates module arrays. (You only need this if you have
allocatable arrays).</p>
</li>
</ul>
<p align="justify">F90 modules are very similar to classes
in Java and
C++; they allow you to group data and the routines which work on the
data in a single package.</p>
<p align="justify">Theoretically, each GEOS&#8211;Chem routine
and/or
variable should belong to a module. In practice, this is not true, as
we do have common blocks and separate subroutine and function files
from some of the older routines which were written by 3rd party
sources. <span class="size16i">However, all new code for
GEOS&#8211;Chem should be written in module form</span>.</p>
<p align="justify">Also, it is OK for modules to reference
other
modules. If Module B references Module A, all that you have to do is to
make sure that Module B declaration in the Makefile refers to Module A.
NOTE: With the development of the column code, we strongly recommend
that new modules, subroutines and&nbsp; functions (even in existing
modules) do not refer to different modules for gridded variables
(dependent on longitude, latitude, altitude) and functions. These
should be passed through the argument list instead. <br>
</p>
<p><img src="../../../img/black_rule.jpg" height="2" width="100%"></p>
<p class="size14bi" align="center"><a href="../../man.v8-03-01/appendix_6.html">Previous</a> | <a href="../../man.v8-03-01/appendix_8.html">Next</a> | <a href="../../man.v8-03-01/appendix_7.html" target="_parent">Printable
View (no frames)</a></p>
</body></html>